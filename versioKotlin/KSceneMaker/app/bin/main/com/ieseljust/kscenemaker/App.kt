/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */

package com.ieseljust.kscenemaker

import kotlin.system.exitProcess        // Per utilitzar exitPRocess

// Imports per gestionar el color de les imatges
import java.awt.Color;

class App {

    var escena=Escena()

    fun getColor(color:String):Color {
        /*
         * Mètode auxiliar per tal de "traduir" els colors en mode text a la seua
         * representació com a constants en awt.Color
         */

        return when (color) {
            "roig" -> Color.RED
            "verd" -> Color.GREEN
            "blau" -> Color.BLUE
            "groc" -> Color.YELLOW
            "magenta" -> Color.MAGENTA
            "cyan" -> Color.CYAN
            "blanc" -> Color.WHITE
            "negre" -> Color.BLACK
            "gris" -> Color.GRAY
            "grisClar" -> Color.LIGHT_GRAY
            "grisFosc" -> Color.DARK_GRAY
            "rosa" -> Color.PINK
            "taronja" -> Color.ORANGE
            else -> Color.BLACK
        }
    }



    fun addFigura(figura: List<String>){
        val tipusFigura:String
        tipusFigura=figura[0]
        when (tipusFigura){
            "rectangle" -> {
                try{
                    val x=figura[1].toInt()
                    val y=figura[2].toInt()
                    val w=figura[3].toInt()
                    val h=figura[4].toInt()
                    val color=figura[5]
               
                        // Si tot és correcte creem la figura rectangle
                    var nouRect=Rectangle(x, y, w, h, this.getColor(color))
                    // I l'afegim a la llista
                    escena.add(nouRect)
                } catch (err:Exception){
                    println("\u001B[31m Arguments incorrectes \u001B[0m");
                }
               
            }
            "cercle" -> {
                try{
                    val x=figura[1].toInt()
                    val y=figura[2].toInt()
                    val r=figura[3].toInt()
                    val color=figura[4]
               
                        // Si tot és correcte creem la figura cercle
                    var nouCer=Cercle(x, y, r,this.getColor(color))
                    // I l'afegim a la llista
                    escena.add(nouCer)
                } catch (err:Exception){
                    println("\u001B[31m Arguments incorrectes \u001B[0m");
                }
               
            }
            "quadrat" -> {
                try{
                    val x=figura[1].toInt()
                    val y=figura[2].toInt()
                    val w=figura[3].toInt()
                    val color=figura[4]
               
                        // Si tot és correcte creem la figura quadrat
                    var nouQua=Quadrat(x, y, w,this.getColor(color))
                    // I l'afegim a la llista
                    escena.add(nouQua)
                } catch (err:Exception){
                    println("\u001B[31m Arguments incorrectes \u001B[0m");
                }
               
            }
            "ellipse" -> {
                try{
                    val x=figura[1].toInt()
                    val y=figura[2].toInt()
                    val w=figura[3].toInt()
                    val h=figura[4].toInt()
                    val color=figura[5]
               
                        // Si tot és correcte creem la figura el·lipse
                    var nouEli=Elipse(x, y, w, h, this.getColor(color))
                    // I l'afegim a la llista
                    escena.add(nouEli)
                } catch (err:Exception){
                    println("\u001B[31m Arguments incorrectes \u001B[0m");
                }
               
            }
            "linia" -> {
                try{
                    val x=figura[1].toInt()
                    val y=figura[2].toInt()
                    val x2=figura[3].toInt()
                    val y2=figura[4].toInt()
                    val color=figura[5]
               
                        // Si tot és correcte creem la "figura" linia
                    var nouLi=Linia(x, y, x2, y2, this.getColor(color))
                    // I l'afegim a la llista
                    escena.add(nouLi)
                } catch (err:Exception){
                    println("\u001B[31m Arguments incorrectes \u001B[0m");
                }
               
            }
            "texto" -> {
                try{
                    val x=figura[1].toInt()
                    val y=figura[2].toInt()
                    val color=figura[3]
                    var texto=figura[4]
                    for(num in 5..figura.size-1){
                        texto=texto+" "+figura[num]
                       }
                    
               
                        // Si tot és correcte creem la "figura" linia
                    var nouTex=Texto(x, y, this.getColor(color),texto)
                    // I l'afegim a la llista
                    escena.add(nouTex)
                } catch (err:Exception){
                    println("\u001B[31m Arguments incorrectes \u001B[0m");
                }
               
            }



            // TO-DO: Afegir la resta de figures ->FET
            
            else -> {
                println("\u001B[31m Figura no implementada \u001B[0m");
            }

        } // when

    }

    fun startCli(){
        do {
            // Preguntem la següent figura a emmagatzemar
            print("# Figura: ")
            
            var ordre:String = readLine()!!
            
            // Separem l'ordre introduida pel teclat en la forma: 
            // "Figura Posicio Mida  Color"
            var components=ordre.split(" ")
            var figura = components[0];

            when (figura) {
                in arrayOf("rectangle", "cercle", "linia", "quadrat", "ellipse", "texto") ->{
                    addFigura(components);
                }
                
                "dimensions" -> {
                    // TO-DO: Agafar les dimensions de l'ordre 
                    // i modificar les propietats de l'escena
               
                    var components2=ordre.split(" ")
                    escena.tamX=Integer.parseInt(components2[1]);
                    escena.tamY=Integer.parseInt(components2[2]);
                    
                    
                }
                "list" -> escena.renderText()
                "render" -> escena.renderScene()

                "remotelist" ->{
                    try {
                        // Descarrega l'index de figures del servidor remot
                        val liniaFitxers:ArrayList<String>? // Pot ser null
                        liniaFitxers=RemoteManager.download("index.php")
                        // Ús del safe Call Operator
                        var fitxers:List<String>?
                        fitxers=liniaFitxers?.get(0)?.split("<br/>")
                        
                        for (fitxer in fitxers.orEmpty()) {
                                println(fitxer)
                            }
                            
                    } catch (e:Exception) {
                        println("Excepció en la càrrega del fitxer: ")
                        println(e)
                    }

                 
                }

                "get" ->{               
                    try {
                        val fitxer:String=components[1]
                        // Descarrega l'index de figures del servidor remot
                        val novesFigures:ArrayList<String>? // Pot ser null
                        novesFigures=RemoteManager.download(fitxer)

                        // Creem una nova escena
                        escena=Escena()

                        // La recorrem
                        for (linia in novesFigures?.get(0)?.split("\n").orEmpty()) {
                            var items:List<String>?=linia.split(" ")
                            
                            when (items!![0]) {
                                in arrayOf("rectangle", "cercle", "linia", "quadrat", "ellipse","texto") ->{
                                    addFigura(items);
                                }
                
                                "dimensions" -> {
                                    
                                    escena.tamX=Integer.parseInt(items[1]);
                                    escena.tamY=Integer.parseInt(items[2]);
                                    
                                }
                            
                        }// When
                    }
                        

                    } catch (e:Exception) {
                        println("Excepció en la càrrega del fitxer: ")
                        println(e)
                    }
                }

                "quit" -> {
                    exitProcess(0)
                }
                
                else ->{
                    println("\u001B[31m Figura no reconeguda \u001B[0m");
                }
            }

        } while (true);
    }
}

fun main(args: Array<String>) {
    var myApp=App()
    myApp.startCli()
}